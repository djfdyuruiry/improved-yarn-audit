#! /usr/bin/env node
const { execSync, spawn } = require("child_process")
const { randomBytes } = require("crypto")
const {
  existsSync,
  createReadStream,
  createWriteStream,
  mkdtempSync,
  readFileSync,
  rmSync,
  statSync,
  unlinkSync
} = require("fs")
const { tmpdir } = require("os")
const path = require("path")
const { env, exit, platform } = require("process")
const { createInterface } = require("readline")

const GITHUB_ADVISORY_CODE = "GHSA"

const joinPath = path.join
const isWindows = platform === "win32"
const yarnCommand = `yarn${isWindows ? ".cmd" : ""}`

const packageInfo = require(joinPath(__dirname, "..", "package.json"))

const optionFlags = {
  severity: ["--min-severity", "-s"],
  exclude: ["--exclude", "-e"],
  retryNetworkIssues: ["--retry-on-network-failure", "-r"],
  ignoreDevDependencies: ["--ignore-dev-deps", "-i"],
  failOnMissingExclusions: ["--fail-on-missing-exclusions", "-f"],
  ignoreTransitiveDeps: ["--ignore-transitive-deps", "-t"],
  auditAllWorkspaces: ["--all-workspaces", "-a"],
  debug: ["--debug", "-d"],
  version: ["--version", "-v"],
  help: ["--help", "-h"]
}

const severityToIntMap = {
  info: 0,
  low: 1,
  moderate: 2,
  high: 3,
  critical: 4
}

const maxSeverityNameLength = 8

const exclusionsFileName = ".iyarc"

let minSeverityName = "low"
let minSeverity = severityToIntMap[minSeverityName]
let excludedAdvisories = []
let ignoreDevDependencies = false
let failOnMissingAdvisoryExclusions = false
let ignoreTransitiveDeps = false
let auditAllWorkspaces = false
let debugEnabled = false
let shouldRetryNetworkErrors = false
let auditResultsFilePath = "/dev/null"

function severityShouldBeIgnored(severity) {
  return severityToIntMap[severity] < minSeverity
}

function flatMap(arr, callback) {
  let arrays = arr
  let returnArray = []

  if (typeof callback === "function") {
    arrays = arr.map(callback)
  }

  arrays.forEach((a) => a.forEach((i) => returnArray.push(i)))

  return returnArray
}

async function logDebug(strOrFunc) {
  if (!debugEnabled) {
    return
  }

  let output = typeof strOrFunc === "function" ? await strOrFunc() : strOrFunc

  console.log(`DEBUG: ${output}`)
}

function checkForMissingExclusions(allAdvisories) {
  const missingExcludedAdvisories = excludedAdvisories.filter(
    (ea) =>
      allAdvisories.find((a) => a.id === ea || a.github_advisory_id === ea) ===
      undefined
  )

  if (missingExcludedAdvisories.length < 1) {
    logDebug("No missing advisory exclusions found")

    return
  }

  console.log()

  console.log(
    "WARNING: One or more excluded audit advisories were missing from yarn audit output: " +
      `${missingExcludedAdvisories.join(",")}`
  )

  if (failOnMissingAdvisoryExclusions) {
    console.error(
      `ERROR: ${optionFlags.failOnMissingExclusions.join(
        "/"
      )} was specified, ` +
        "exit code will indicate number of missing exclusions"
    )
    process.exit(missingExcludedAdvisories.length)
  }
}

function buildAdvisoryReport(
  devDependencyAdvisoryIds,
  severityIgnoredAuditAdvisories,
  excludedAuditAdvisories
) {
  let filteredAdvisoryReport = ""

  if (ignoreDevDependencies && devDependencyAdvisoryIds.length > 0) {
    filteredAdvisoryReport +=
      `\n${devDependencyAdvisoryIds.length} ignored because ` +
      `they are dev dependencies\n`
  }

  if (severityIgnoredAuditAdvisories.length > 0) {
    filteredAdvisoryReport +=
      `\n${severityIgnoredAuditAdvisories.length} ignored because ` +
      `severity was lower than "${minSeverityName}"\n`
  }

  if (excludedAuditAdvisories.length > 0) {
    filteredAdvisoryReport += `\n${excludedAuditAdvisories.length} ignored because of advisory exclusions\n`
  }

  return filteredAdvisoryReport
}

function printAuditReport(
  {
    filteredAuditAdvisories,
    devDependencyAdvisories,
    devDependencyAdvisoryIds,
    severityIgnoredAuditAdvisories,
    excludedAuditAdvisories
  },
  yarnMajorVersion
) {
  logDebug(() => `Dev audit advisories:\n${toJson(devDependencyAdvisories)}\n`)
  logDebug(
    () => `Excluded audit advisories:\n${toJson(excludedAuditAdvisories)}\n`
  )
  logDebug(
    () =>
      `Severity ignored advisories:\n${toJson(
        severityIgnoredAuditAdvisories
      )}\n`
  )

  const filteredAdvisoryReport = buildAdvisoryReport(
    devDependencyAdvisoryIds,
    severityIgnoredAuditAdvisories,
    excludedAuditAdvisories
  )

  console.log(
    `Found ${filteredAuditAdvisories.length} vulnerabilities\n${filteredAdvisoryReport}`
  )

  filteredAuditAdvisories.forEach((a) => {
    const formattedSeverity = a.severity
      .toUpperCase()
      .padEnd(maxSeverityNameLength, " ")

    const affectedModulePaths = flatMap(a.findings, (f) => f.paths)
    const affectedModules = affectedModulePaths.join(", ")

    console.log(`Vulnerability Found:

  Severity: ${formattedSeverity}
  Modules: ${affectedModules}
  URL: ${a.url}
`)
  })

  if (filteredAuditAdvisories.length > 0) {
    console.log()
  }

  console.log(`Run 'yarn${yarnMajorVersion === 3 ? " npm " : " "}audit' for more information`)
}

const sleep = (ms) => new Promise((r) => setTimeout(r, ms))

function isNonExcludedAdvisory(advisory, devDependencyAdvisoryIds) {
  return (
    !severityShouldBeIgnored(advisory.severity) &&
    !excludedAdvisories.includes(advisory.id) &&
    !excludedAdvisories.includes(advisory.github_advisory_id) &&
    (!devDependencyAdvisoryIds.includes(advisory.id) || !ignoreDevDependencies)
  )
}

function parseAuditJson(jsonString) {
  try {
    return JSON.parse(jsonString)
  } catch (ex) {
    console.error(`ERROR: Unable to parse yarn audit output: ${ex}`)
    console.error("Try running `yarn audit` for more info")

    process.exit(1)
  }
}

async function getAuditSummary() {
  logDebug("Getting yarn audit summary")

  let auditSummary = ""

  await iterateOverAuditResults((l) => (auditSummary = l))

  return auditSummary
}

async function handleAuditNetworkError(invokeYarnAuditFunc) {
  const error = "ERROR: Network error occurred when querying audit registry"

  if (!shouldRetryNetworkErrors) {
    errorAndExit(`${error}\n\n${await dumpAuditResultsAsString()}`)
  }

  console.error(`${error}, retrying...\n`)

  await sleep(1000)

  return await runYarnAudit(invokeYarnAuditFunc)
}

async function networkErrorHasOccurred() {
  let networkErrorHasOccurred = false

  if (existsSync(auditResultsFilePath)) {
    await iterateOverAuditResults(
      (a) =>
        (networkErrorHasOccurred =
          networkErrorHasOccurred || a.includes("Error: Request failed "))
    )
  }

  logDebug(`networkErrorHasOccurred: ${networkErrorHasOccurred}`)

  return networkErrorHasOccurred
}

async function dumpAuditResultsAsString() {
  let output = ""

  await iterateOverAuditResults((l) => (output += l))

  return output
}

async function iterateOverAuditResults(action) {
  logDebug("Iterating over audit results")

  const auditResultsFileStream = getAuditResultsFileStream("r")
  const iterator = createInterface(auditResultsFileStream)

  iterator.on("line", action)

  await new Promise((resolve) => iterator.on("close", resolve))

  auditResultsFileStream.close()
}

function getAuditResultsFileStream(mode) {
  logDebug(
    `Opening file stream for file '${auditResultsFilePath}' in '${mode}' mode`
  )

  if (mode === "w") {
    return createWriteStream(auditResultsFilePath)
  }

  return createReadStream(auditResultsFilePath)
}

async function cleanupAuditResultsFile() {
  if (!existsSync(auditResultsFilePath)) {
    return
  }

  if (isWindows) {
    // workaround for unlinkSync issues on windows
    execSync(`del "${auditResultsFilePath}"`)

    return
  }

  unlinkSync(auditResultsFilePath)
}

async function processAuditResult(
  result,
  {
    allAdvisories,
    filteredAuditAdvisories,
    devDependencyAdvisories,
    devDependencyAdvisoryIds,
    severityIgnoredAuditAdvisories,
    excludedAuditAdvisories
  },
  devDependenciesRegex
) {
  allAdvisories.push(result)

  if (devDependenciesRegex) {
    const isDevDependencyAdvisory = flatMap(
      result.findings,
      (f) => f.paths
    ).every((d) => d.match(devDependenciesRegex))

    if (isDevDependencyAdvisory) {
      devDependencyAdvisories = devDependencyAdvisories.concat(result)
      devDependencyAdvisoryIds = devDependencyAdvisories.concat(
        devDependencyAdvisories.map((d) => d.id)
      )
    }
  }

  if (isNonExcludedAdvisory(result, devDependencyAdvisoryIds)) {
    filteredAuditAdvisories.push(result)
  }

  if (
    (excludedAdvisories.includes(result.id) ||
      excludedAdvisories.includes(result.github_advisory_id)) &&
    !severityShouldBeIgnored(result.severity)
  ) {
    excludedAuditAdvisories.push(result)
  }

  if (severityShouldBeIgnored(result.severity)) {
    severityIgnoredAuditAdvisories.push(result)
  }
}

async function executeYarn(params, outputStream) {
  logDebug(() => `Executing yarn with params:\n${toJson(params)}`)

  const yarnProcess = spawn(yarnCommand, params, {
    env,
    stdio: ["pipe", outputStream, outputStream]
  })

  const exitCode = await new Promise((resolve, reject) =>
    yarnProcess.on("exit", resolve).on("error", reject)
  )

  outputStream.close()

  logDebug(
    () => `Yarn output size: ${statSync(auditResultsFilePath).size} bytes`
  )

  return exitCode
}

async function invokeYarnAuditV3() {
  const auditParams = ["npm", "audit", "--json", `--severity=${minSeverityName}`]

  if (ignoreDevDependencies) {
    auditParams.push("--environment=production")
  }

  if (!ignoreTransitiveDeps) {
    auditParams.push("--recursive")
  }

  if (auditAllWorkspaces) {
    auditParams.push("--all")
  }

  for (const excludedAdvisory of excludedAdvisories) {
    auditParams.push("--exclude", excludedAdvisory)
  }

  cleanupAuditResultsFile()

  const auditResultsFileStream = getAuditResultsFileStream("w")
  const exitCode = await new Promise((resolve) =>
    auditResultsFileStream.on("open", async () => {
      let exitCode = await executeYarn(
        auditParams,
        auditResultsFileStream
      )

      resolve(exitCode)
    })
  )

  return exitCode
}

async function invokeYarnAuditV1() {
  const auditParams = ["audit", "--json", `--level=${minSeverityName}`]

  if (ignoreDevDependencies) {
    auditParams.push("--groups=dependencies")
  }

  cleanupAuditResultsFile()

  const auditResultsFileStream = getAuditResultsFileStream("w")
  const exitCode = await new Promise((resolve) =>
    auditResultsFileStream.on("open", async () => {
      let exitCode = await executeYarn(
        auditParams,
        auditResultsFileStream
      )

      resolve(exitCode)
    })
  )

  return exitCode
}

async function runYarnAudit(invokeYarnAuditFunc) {
  console.log("Running yarn audit...\n")

  const exitCode = await invokeYarnAuditFunc()

  if (await networkErrorHasOccurred()) {
    return await handleAuditNetworkError(invokeYarnAuditFunc)
  }

  if (exitCode === 1) {
    errorAndExit(
      `ERROR: Yarn audit error:\n${await dumpAuditResultsAsString()}`
    )
  }
}

async function runAuditReportV3(auditReportSink, devDependenciesRegex) {
  logDebug("executing runAuditReportV3()")

  await runYarnAudit(invokeYarnAuditV3)

  const yarnAuditReport = JSON.parse(readFileSync(auditResultsFilePath).toString())

  logDebug(() => `Audit summary:\n${toJson(yarnAuditReport.metadata)}\n`)

  for (const [_, result] of Object.entries(yarnAuditReport.advisories)) {
    await processAuditResult(result, auditReportSink, devDependenciesRegex)
  }
}

async function runAuditReportV1(auditReportSink, devDependenciesRegex) {
  logDebug("executing runAuditReportV1()")

  await runYarnAudit(invokeYarnAuditV1)

  logDebug(async () => {
    let auditSummaryJson = await getAuditSummary()
    let auditSummary = toJson(JSON.parse(auditSummaryJson))

    return `Audit summary:\n${auditSummary}\n`
  })

  await iterateOverAuditResults(async (resultJson) => {
    const potentialResult = parseAuditJson(resultJson)

    if (
      typeof potentialResult.type !== "string" ||
      potentialResult.type !== "auditAdvisory"
    ) {
      return
    }

    const result = potentialResult.data.advisory

    await processAuditResult(result, auditReportSink, devDependenciesRegex)
  })
}

function getDevDependenciesRegex() {
  if (!existsSync("package.json")) {
    console.log(
      "WARNING: No package.json was found in the current working directory"
    )
    logDebug("Dev dependencies will not be ignored")

    return
  }

  const packageJson = readFileSync("package.json")
  const package = JSON.parse(packageJson)

  let devDependencies = []

  if (
    typeof package === "object" &&
    typeof package.devDependencies === "object"
  ) {
    devDependencies = Object.keys(package.devDependencies)
  }

  if (devDependencies.length < 1) {
    logDebug("No dev dependencies installed")
    logDebug("Dev dependencies will not be ignored")

    return
  }

  logDebug(() => `Dev dependencies: ${devDependencies.join(", ")}`)

  ignoreDevDependencies
    ? logDebug("Dev dependencies will be ignored")
    : logDebug("Dev dependencies will not be ignored")

  const devDependenciesOr = devDependencies.map((d) => `(${d})`).join("|")
  const devDependenciesRegex = `^${devDependenciesOr}>*.*$`

  logDebug(`Dev dependencies regex: ${devDependenciesRegex}`)

  return new RegExp(devDependenciesRegex)
}

async function runAuditReport(yarnMajorVersion) {
  const auditReportSink = {
    allAdvisories: [],
    filteredAuditAdvisories: [],
    severityIgnoredAuditAdvisories: [],
    excludedAuditAdvisories: [],
    devDependencyAdvisories: [],
    devDependencyAdvisoryIds: []
  }
  const devDependenciesRegex = getDevDependenciesRegex()

  await (yarnMajorVersion === 1
    ? runAuditReportV1(auditReportSink, devDependenciesRegex)
    : runAuditReportV3(auditReportSink, devDependenciesRegex)
  )

  printAuditReport(auditReportSink, yarnMajorVersion)

  checkForMissingExclusions(auditReportSink.allAdvisories)

  return auditReportSink.filteredAuditAdvisories.length
}

async function withTempDir(action, cleanupAction) {
  const prefix = joinPath(tmpdir(), "iya")
  const tempDirPath = mkdtempSync(prefix)

  try {
    return await action(tempDirPath)
  } finally {
    if (cleanupAction) {
      cleanupAction()
    }

    rmSync(tempDirPath, { recursive: true })
  }
}

async function withTempFile(action, cleanupAction) {
  return await withTempDir(async (tempDirPath) => {
    const randomName = randomBytes(16).toString("hex")
    const tmpFilePath = joinPath(tempDirPath, randomName)

    logDebug(`Temporary file path: ${tmpFilePath}`)

    return await action(tmpFilePath)
  }, cleanupAction)
}

async function getYarnMajorVersion() {
  const versionOutput = await withTempFile(async (filePath) => 
    await new Promise((resolve) => {
      const versionStream = createWriteStream(filePath)

      versionStream.on("open", async () => {
        let exitCode = await executeYarn(
          [ "--version" ],
          versionStream
        )

        versionStream.close()

        const yarnOutput = readFileSync(filePath).toString()

        if (exitCode != 0) {
          errorAndExit(`Unable to check Yarn version: ${yarnOutput}`)
        }

        resolve(yarnOutput)
      })
    })
  )

  const versionParts = !isNullOrEmpty(versionOutput) ? versionOutput.split(".") : []
  const yarnMajorVersion = versionParts.length > 0 ? parseInt(versionParts[0]) : NaN

  if (yarnMajorVersion === NaN) {
    errorAndExit(`Unable to parse Yarn version from output: ${versionOutput}`)
  }

  return { yarnMajorVersion, yarnVersion: versionOutput.replace("\n", "") }
}

function toJson(value) {
  return JSON.stringify(value, null, 2)
}

function printVersionAndExit() {
  errorAndExit(packageInfo.version, 1)
}

function printUsageAndExit() {
  errorAndExit(`
improved-yarn-audit [OPTIONS]

Options:

  --min-severity, -s                  Minimum severity to treat as an error, default is low (info, low, moderate, high, critical)
  --exclude, -e                       CSV list of advisory ID's to ignore, e.x. 432,564 (this overrides .iyarc)
  --retry-on-network-failure, -r      Retry audit if NPM registry throws a network error
  --ignore-dev-deps, -i               Ignore advisories for dev dependencies
  --fail-on-missing-exclusions, -f    Return a non-zero exit code when advisory exclusions are no longer detected by yarn audit
  --ignore-transitive-deps, -t        Ignore vulnerabilities in transitive dependencies (Yarn v3.x only)
  --all-workspaces, -a                Audit all workspaces (Yarn v3.x only)
  --debug, -d                         Print out raw audit report's and advisory details
  --version, -v                       Print version info and exit
  --help, -h                          Show this information

The CSV list of advisory ID's can also be provided in a '.iyarc' file in the current working directory. This file also supports
comments, lines beginning with a '#' character are ignored.
`, 1)
}

function errorAndExit(msg, code = 1) {
  console.error(msg)
  process.exit(code)
}

function parseJSONSafeExcludeList(str) {
  return str
    .split(",")
    .map((option) => {
      if (option.startsWith(GITHUB_ADVISORY_CODE)) {
        return `"${option}"`
      }

      return option
    })
    .filter((str) => str)
    .join(",")
}

function parseConfigToJson(str) {
  const jsonSafeString = parseJSONSafeExcludeList(str)

  return JSON.parse(`[${jsonSafeString}]`)
}

function isValidConfigFormat(str) {
  try {
    const testExcludeList = parseConfigToJson(str)

    testExcludeList.forEach((excludeOption) => {
      if (
        parseInt(excludeOption) === NaN &&
        !excludeOption.startsWith(GITHUB_ADVISORY_CODE)
      ) {
        throw "Invalid format"
      }
    })

    return true
  } catch {
    return false
  }
}

function isNullOrEmpty(str) {
  return typeof str !== "string" || str.trim() === ""
}

function loadExclusionsFromFileIfPresent() {
  if (!existsSync(exclusionsFileName)) {
    logDebug(`No ${exclusionsFileName} found in working directory`)
    return
  }

  if (excludedAdvisories.length > 0) {
    console.log(
      `WARNING: Ignoring ${exclusionsFileName} as exclusions were passed in via command line`
    )
    return
  }

  let matchedNpmAdvisories = readFileSync(exclusionsFileName)
    .toString()
    .match(/(?<=^(?:\d+,)*)\d+(?=(?:,\d+)*$)/gm)

  let matchedGithubAdvisories = readFileSync(exclusionsFileName)
    .toString()
    .match(/^(GHSA-([a-z0-9]{4})-([a-z0-9]{4})-([a-z0-9]{4}))$/gm)

  let advisoriesNPMCsv = matchedNpmAdvisories
    ? matchedNpmAdvisories.join(",")
    : ""

  let advisoriesGithubCsv = matchedGithubAdvisories
    ? matchedGithubAdvisories.join(",")
    : ""

  let advisoriesCsv = [advisoriesNPMCsv, advisoriesGithubCsv].join(",")

  logDebug(`.iyarc contents (excluding comments): ${advisoriesCsv}`)

  if (!isValidConfigFormat(advisoriesCsv)) {
    errorAndExit(
      `ERROR: ${exclusionsFileName} is not in the correct format, excluded advisories must be provided on ` +
        "individual lines, or as a CSV list (eg: '2341,21,43,GHSA-42xw-2xvc-qx8mas')"
    )
  }

  console.log(`Reading excluded advisories from ${exclusionsFileName}`)

  excludedAdvisories = parseConfigToJson(advisoriesCsv)
}

function isFlag(flags, ...strings) {
  return (
    strings.filter(
      (s) => !isNullOrEmpty(s) && flags.includes(s.trim().toLowerCase())
    ).length > 0
  )
}

function parseCommandLineArgs() {
  process.argv.reduce((a, b) => {
    if (isFlag(optionFlags.version, a, b)) {
      printVersionAndExit()
    }

    if (isFlag(optionFlags.help, a, b)) {
      printUsageAndExit()
    }

    if (isFlag(optionFlags.exclude, a) && !isNullOrEmpty(b)) {
      if (isValidConfigFormat(b)) {
        excludedAdvisories = parseConfigToJson(b)
      } else {
        errorAndExit(`ERROR: Unable to parse --exclude option value: ${b}`)
      }
    }

    if (isFlag(optionFlags.severity, a) && !isNullOrEmpty(b)) {
      if (![null, undefined].includes(severityToIntMap[b.toLowerCase()])) {
        minSeverityName = b.trim().toLowerCase()
        minSeverity = severityToIntMap[minSeverityName]
      } else {
        errorAndExit(
          `ERROR: Unrecognised --min-severity option value: ${b.trim()}`
        )
      }
    }

    if (isFlag(optionFlags.debug, a, b)) {
      debugEnabled = true
    }

    if (isFlag(optionFlags.retryNetworkIssues, a, b)) {
      shouldRetryNetworkErrors = true
    }

    if (isFlag(optionFlags.ignoreDevDependencies, a, b)) {
      ignoreDevDependencies = true
    }

    if (isFlag(optionFlags.failOnMissingExclusions, a, b)) {
      failOnMissingAdvisoryExclusions = true
    }

    if (isFlag(optionFlags.ignoreTransitiveDeps, a, b)) {
      ignoreTransitiveDeps = true
    }
  
    if (isFlag(optionFlags.auditAllWorkspaces, a, b)) {
      auditAllWorkspaces = true
    }
  
    return b
  }, "")
}

async function main() {
  parseCommandLineArgs()

  console.log(`Improved Yarn Audit - v${packageInfo.version}`)
  console.log()

  const { yarnMajorVersion, yarnVersion } = await getYarnMajorVersion()

  if (yarnMajorVersion !== 1 && yarnMajorVersion !== 3) {
    errorAndExit(`Yarn version not supported: ${yarnVersion}`)
  }

  console.log(`Detected Yarn Version: v${yarnVersion}`)

  logDebug(`shouldRetryNetworkErrors = ${shouldRetryNetworkErrors}`)
  logDebug(`ignoreDevDependencies = ${ignoreDevDependencies}`)

  loadExclusionsFromFileIfPresent()

  console.log(`Minimum severity level to report: ${minSeverityName}`)

  console.log(
    excludedAdvisories.length > 0
      ? `Excluded Advisories: ${JSON.stringify(excludedAdvisories)}\n`
      : ""
  )

  try {
    const advisoryCount = await withTempFile(async (filePath) => {
      auditResultsFilePath = filePath

      return await runAuditReport(yarnMajorVersion)
    }, cleanupAuditResultsFile)

    exit(advisoryCount)
  } catch (e) {
    console.error("Audit failed due to an error: \n")
    console.error(e)
  }

  exit(1)
}

main()
